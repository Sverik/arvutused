<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
    <title>Phaser - Making your first game, part 9</title>
    <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript" src="js/Gate.js"></script>
<script type="text/javascript" src="js/Target.js"></script>
<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'arvutused', { preload: preload, create: create, update: update });

function preload() {

    game.load.image('sky', 'assets/sky.png');
    game.load.spritesheet('kast', 'assets/sinine_kast.png', 48, 48);
    game.load.image('asukoht', 'assets/koht.png');
    game.load.image('ground', 'assets/platform.png');
    game.load.image('star', 'assets/star.png');
    game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
    
}

var player;
var platforms;
var cursors;

var targetGroup;
var notesGroup;
var dispensers;

var stars;
var score = 0;
var scoreText;

var timer;
var emitter;

var valueLimit = 7;
var gatePos = [30, 290, 550];
var activeGates = 0;
var gateClearedActionRunning = false;

function create() {
    timer = game.time.create(false);
    timer.start();
    
    //  We're going to be using physics, so enable the Arcade Physics system
    game.physics.startSystem(Phaser.Physics.ARCADE);

    //  A simple background for our game
    game.add.sprite(0, 0, 'sky');

    //  The platforms group contains the ground and the 2 ledges we can jump on
    platforms = game.add.group();
    
    //  We will enable physics for any object that is created in this group
    platforms.enableBody = true;

    // Here we create the ground.
    var ground = platforms.create(0, game.world.height - 32, 'ground');

    //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
    ground.scale.setTo(2, 1);

    //  This stops it from falling away when you jump on it
    ground.body.immovable = true;

    //  Now let's create two ledges
/*
    var ledge = platforms.create(400, 400, 'ground');
    ledge.body.immovable = true;

    ledge = platforms.create(-150, 250, 'ground');
    ledge.body.immovable = true;
*/
    
    notesGroup = game.add.group();

    // targets
    targetGroup = game.add.group();
    targetGroup.enableBody =  true;
    
    dispensers = new Array();
    for (var k = 0 ; k < 8 ; k++) {
        createDispenser(70 + k * 85, 490);
    }

    // The player and its settings
    player = game.add.sprite(32, game.world.height - 100, 'dude');

    //  We need to enable physics on the player
    game.physics.arcade.enable(player);

    //  Player physics properties. Give the little guy a slight bounce.
    player.body.bounce.y = 0.2;
    player.body.gravity.y = 300;
    player.body.collideWorldBounds = true;

    //  Our two animations, walking left and right.
    player.animations.add('left', [0, 1, 2, 3], 10, true);
    player.animations.add('right', [5, 6, 7, 8], 10, true);
    
    //  Finally some stars to collect
    stars = game.add.group();
    stars.enableBody = true;

    //  The score
    scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });

    //  Our controls.
    cursors = game.input.keyboard.createCursorKeys();
    
    // Emitter
    emitter = game.add.emitter(0, 0, 100);
    emitter.makeParticles('star');
    emitter.gravity = 150;
    
    // Gates
    initGates();
    
}

function update() {

    //  Collide the player and the stars with the platforms
    game.physics.arcade.collide(player, platforms);
    game.physics.arcade.collide(stars, platforms);
    
    //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function
    game.physics.arcade.overlap(player, stars, collectStar, function(player, star){
        // locked res cannot be picked up by the player
        if (star.atTarget && star.atTarget.locked) {
            return false;
        }
    }, this);

    //  Reset the players velocity (movement)
    player.body.velocity.x = 0;

    if (cursors.left.isDown)
    {
        //  Move to the left
        player.body.velocity.x = -150;

        player.animations.play('left');
    }
    else if (cursors.right.isDown)
    {
        //  Move to the right
        player.body.velocity.x = 150;

        player.animations.play('right');
    }
    else
    {
        //  Stand still
        player.animations.stop();

        player.frame = 4;
    }
    
    //  Allow the player to jump if they are touching the ground.
    if (cursors.up.isDown && player.body.touching.down)
    {
        player.body.velocity.y = -350;
    }
    
    // Dispense new res, if needed.
    for (var k in dispensers) {
    	var target = dispensers[k];
        if (target.filled) {
            continue;
        }
        var res = createRes(k);
        target.putRes(res);
    }
    
    // All gates cleared, do something.
    if ( ! gateClearedActionRunning && activeGates <= 0) {
    	gateClearedActionRunning = true;
    	timer.add(300, addPrize, this);
    }
}

function addPrize() {
    var prize = game.add.sprite(game.world.width / 2, game.world.height - 300, 'dude');
    var anim = Math.random();
    if (anim < 0.3) {
        prize.animations.add('left', [0, 1, 2, 3], 10, true);
    	prize.animations.play('left');
    } else if (anim < 0.6) {
        prize.animations.add('right', [5, 6, 7, 8], 10, true);
    	prize.animations.play('right');
    } else {
		prize.frame = 4;
    	prize.animations.stop();
    }
    // prize.frame = Math.floor(Math.random() * prize.animations.frameTotal);
	console.log("b " + prize.tint);
	var color = Phaser.Color.HSVColorWheel(0.5, 0.8)[Math.floor(Math.random() * 360)];
	var string = Phaser.Color.getColor(color.r, color.g, color.b);
// 	for (var p in tint.rgba) {
// 		console.log("tint.rgba" + p + " = " + tint.rgba[p]);
// 	}
	console.log("s " + string);
    prize.tint = string;
	console.log("a " + prize.tint);
    prize.inputEnabled = true;
    prize.input.enableDrag(false, true);
    prize.input.useHandCursor = true;
	timer.add(1100, initGates, this);
}

function initGates() {
	for (var i in gatePos) {
		var x = gatePos[i];
		createGate(x, 360);
	}
    gateClearedActionRunning = false;
}

function confetti(gate) {
    var width = (gate.targetCount * gate.targetStep - gate.operatorWidth);
    emitter.x = gate.x + 0.25 * width + Math.random() * width * (0.25 + 0.25);
    emitter.y = gate.y + Math.random() * 30;
    emitter.start(true, 2400, null, 1);
}

function createGate(x, y) {
    var value = Math.ceil(Math.random() * valueLimit);
    var a = Math.floor(Math.random() * value);
    var b = value - a;
    
    var conf = [
        {
            nodeType: NodeTypeEnum.PLUS,
            value: a
        },
        {
            nodeType: NodeTypeEnum.PLUS,
            value: b
        },
        {
            nodeType: NodeTypeEnum.VALUE,
            value: undefined
        }
    ];
    
    var gate = new Gate(conf, x, y, targetGroup);
    gate.afterDestroy = function(thisGate) {
    	activeGates--;
    };
    gate.init();
    activeGates++;
}

function createRes(value) {
    if (value === undefined) {
        value = Math.floor(Math.random()*(valueLimit + 1));
    }

    var star = stars.create(90, game.world.height - 150, 'kast');
    
    star.inputEnabled = true;
    star.input.enableDrag(false, true);
    star.input.useHandCursor = true;
    star.events.onDragStart.add(function(){
        star.dragStart = {
            x: star.x,
            y: star.y
        };
    }, this);
    star.events.onDragStop.add(function(){
        var overlapped = Array();
        game.physics.arcade.overlap(star, targetGroup, function(star, targetSprite) {
            overlapped.push(targetSprite);
        }, function(star, targetSprite) {
            if (targetSprite.target.locked || (targetSprite.target.filled && star.atTarget != targetSprite.target)) {
                return false;
            }
        }, this);

        // find closest
        var c_d2 = 99999;
        var closest = null;
        overlapped.forEach(function(targetSprite){
            var d2 = (targetSprite.x - star.x)*(targetSprite.x - star.x) + (targetSprite.y - star.y)*(targetSprite.y - star.y);
            if (d2 < c_d2) {
                c_d2 = d2;
                closest = targetSprite;
            }
        });
        
        if (closest == null) {
            // return to previous position
            star.x = star.dragStart.x;
            star.y = star.dragStart.y;
        } else {
            // snap and put to closest target
            closest.target.putRes(star);
        }
    }, this);
    
    star.customValue = value;
    star.customText = game.add.text(28, 26, star.customValue.toString(), { font: "24px Arial", fill: "#112200", wordWrap: true, wordWrapWidth: star.width, align: "center" });
    star.customText.anchor.set(0.5);
    star.addChild(star.customText);
    
    return star;
}

function createDispenser(x, y) {
    var target = new Target(targetGroup).init(x, y);
    dispensers.push(target);
}

function collectStar (player, star) {
    
    // Removes the star from the screen
    star.customText.destroy();
    star.destroy();
    
    if (star.atTarget) {
        star.atTarget.filled = false;
        star.atTarget.res = null;
        star.atTarget.onUpdate(null);
    }

    //  Add and update the score
    score += 10;
    scoreText.text = 'Score: ' + score;

}

</script>

</body>
</html>